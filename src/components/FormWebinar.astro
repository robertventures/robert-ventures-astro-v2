---

---

<style>
    .time {
        display: flex;
        justify-content: space-around;

        margin-top: 1rem;
        margin-bottom: 1rem;
    }

    .time div {
        font-weight: 600;
    }
    .form {
        max-width: 366px;

        margin: 0 auto;
    }

    .form-block {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        margin: 0 auto;

        flex-direction: column;
        gap: 0.75rem;

        width: 100%;
        box-sizing: border-box;

        margin-bottom: 1.25rem;
    }

    .name {
        display: flex;
        gap: 0.75rem;
        width: 100%;
    }

    input,
    select {
        border: none;
        flex-grow: 1; /* Allow the input to grow */
        border: 1px solid #afb5bc;
        padding: 1rem 0.75rem;
        width: 100%;
        box-sizing: border-box;

        border-radius: 0.75rem;
    }

    input::placeholder,
    select:invalid {
        color: #737373;
        opacity: 1;
    }

    select {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-color: #fff;
        border: 1px solid #afb5bc;
        width: 100%;

        color: #737373;
    }
    select:required:not(:invalid) {
        color: #1d1d1f;
    }

    button {
        background-color: #5028ff;
        border: none;
        color: #fff;
        border-radius: 0.75rem;

        padding: 1rem 0.75rem;

        font-size: 1.125rem;
        font-weight: 500;

        width: 100%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .signup-error {
        display: none;
        color: red;
        text-align: center;
        margin-top: 0.5rem;
    }

    .loader {
        border: 2px solid #ffffff80; /* semi-transparent white */
        border-top: 2px solid #fff;  /* solid white for the spinner */
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        display: none;
        margin-left: 0.5rem;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }

    @media only screen and (min-width: 990px) {
        .account {
            max-width: none;
        }
    }
</style>

<div class="form">
    <form class="form-cta">
        <h3>Next session in:</h3>
        <div class="time">
            <div class="days">
                <span>0</span>
                <p>days</p>
            </div>
            <div class="hours">
                <span>0</span>
                <p>hours</p>
            </div>
            <div class="minutes">
                <span>0</span>
                <p>minutes</p>
            </div>
            <div class="seconds">
                <span>0</span>
                <p>seconds</p>
            </div>
        </div>
        <div class="form-block">
            <select name="session" required>
                <option value="" disabled selected>Select an upcoming session</option>
            </select>
            <div class="name">
                <input
                    type="text"
                    name="first_name"
                    placeholder="First Name"
                    required
                    class="email-input"
                />
                <input
                    type="text"
                    name="last_name"
                    placeholder="Last Name"
                    required
                    class="email-input"
                />
            </div>
            <input
                type="email"
                name="email"
                placeholder="Enter Your Email"
                required
                class="email-input"
            />
            <input
                type="tel"
                name="phone_number"
                placeholder="Phone Number"
                required
            />
            <select name="invest_intent" required>
                <option disabled selected>How much are you looking to invest?</option>
                <option value="1000">1k</option>
                <option value="5000">5k</option>
                <option value="10000">10k</option>
                <option value="25000">25k</option>
                <option value="50000">50k</option>
                <option value="100000">100k+</option>
            </select>
            <input
                type="text"
                name="bot-field"
                class="bot-field"
                style="display: none;"
            />
        </div>
        <button type="submit">
          <span class="button-text">REGISTER NOW</span>
          <span class="loader" style="display: none;"></span>
        </button>
        <p class="signup-error"></p>
    </form>
</div>

<script>
window.addEventListener("DOMContentLoaded", async () => {
  function computeSessionDate(weekdayName, timeStr, periodStr, timeZoneStr) {
    console.log(`Computing session date for: ${weekdayName} at ${timeStr} ${periodStr} in ${timeZoneStr}`);
    
    // Map day names to day numbers (0 = Sunday, 6 = Saturday)
    const dayMap = {
      "Sunday": 0,
      "Monday": 1, 
      "Tuesday": 2,
      "Wednesday": 3,
      "Thursday": 4,
      "Friday": 5,
      "Saturday": 6
    };
    
    // Parse time string
    const [hours, minutes] = timeStr.split(":").map(num => parseInt(num, 10));
    
    // Handle AM/PM
    let hour24 = hours;
    if (periodStr.toUpperCase() === "PM" && hours < 12) {
      hour24 = hours + 12;
    }
    if (periodStr.toUpperCase() === "AM" && hours === 12) {
      hour24 = 0;
    }
    
    // Get current date in the session's timezone
    const now = new Date();
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: timeZoneStr,
      year: 'numeric',
      month: 'numeric',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      second: 'numeric',
      hour12: false
    });
    
    // Parse parts into a date object
    const parts = formatter.formatToParts(now);
    const dateParts = {};
    parts.forEach(part => {
      if (part.type !== 'literal') {
        dateParts[part.type] = parseInt(part.value, 10);
      }
    });
    
    // Create date for today in the session timezone
    const sessionDate = new Date(Date.UTC(
      dateParts.year,
      dateParts.month - 1,
      dateParts.day,
      hour24,
      minutes,
      0,
      0
    ));
    
    // Adjust to the target day of week
    const currentDayOfWeek = new Date(
      Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day)
    ).getUTCDay();
    
    let daysToAdd = (dayMap[weekdayName] - currentDayOfWeek + 7) % 7;
    
    // If it's the same day, check if the time has passed
    if (daysToAdd === 0) {
      if (dateParts.hour > hour24 || (dateParts.hour === hour24 && dateParts.minute >= minutes)) {
        daysToAdd = 7; // Schedule for next week
      }
    }
    
    // Add days to reach the target day
    sessionDate.setUTCDate(sessionDate.getUTCDate() + daysToAdd);
    
    console.log(`Computed date: ${sessionDate.toISOString()}`);
    return sessionDate;
  }
  
  // Fetch webinar data once
  let data;
  try {
    const response = await fetch("/api/webinar-data", { cache: "no-store" });
    if (!response.ok) {
      console.error("Failed to fetch webinar data:", response.statusText);
      return;
    }
    data = await response.json();

    // Log the fetched webinar data
    console.log("Fetched webinar data:", data);
  } catch (err) {
    console.error("An error occurred while fetching webinar data:", err);
    return;
  }

  // For each form instance on the page
  document.querySelectorAll(".form").forEach((formContainer) => {
    const form = formContainer.querySelector("form.form-cta") as HTMLFormElement;
    const selectEl = form.querySelector("select[name='session']");
    const phoneInput = form.querySelector("input[name='phone_number']");
    const daysSpan = formContainer.querySelector(".days span");
    const hoursSpan = formContainer.querySelector(".hours span");
    const minutesSpan = formContainer.querySelector(".minutes span");
    const secondsSpan = formContainer.querySelector(".seconds span");
    const signupError = form.querySelector(".signup-error");
    const submitButton = form.querySelector("button[type='submit']");
    const buttonText = submitButton.querySelector(".button-text");
    const loader = submitButton.querySelector(".loader");

    // Populate session select with times from API
    const sessions = data.results.filter((item) => {
      try {
        const parsed = JSON.parse(item.id);
        return parsed && parsed.type === "ongoing";
      } catch {
        return false;
      }
    });

    // Process sessions and add to dropdown
    const sessionsWithDates = [];
    sessions.forEach(session => {
      try {
        const details = JSON.parse(session.id);
        console.log("Session from API:", details);
        
        // Create a Date object for the next occurrence
        const nextDate = getNextSessionDate(
          details.day,
          details.time,
          details.period,
          details.timeZone
        );
        
        sessionsWithDates.push({
          session: session,
          nextDate: nextDate
        });
      } catch (error) {
        console.error("Error processing session:", error);
      }
    });

    // Sort by date
    sessionsWithDates.sort((a, b) => a.nextDate.getTime() - b.nextDate.getTime());

    selectEl.innerHTML = '<option value="" disabled selected>Select an upcoming session</option>';
    sessionsWithDates.forEach(item => {
      const session = item.session;
      const nextDate = item.nextDate;
      const details = JSON.parse(session.id);
      
      // Get user's timezone for display purposes
      const userTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      // Format in user's local timezone for display only
      const userTimeOptions = {
        weekday: 'long',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZoneName: 'short'
      };
      
      const userTimeString = nextDate.toLocaleString("en-US", userTimeOptions);
      
      const option = document.createElement("option");
      option.value = session.id;
      option.setAttribute("data-date", nextDate.toISOString());
      option.setAttribute("data-timezone", userTz);  // Add user's timezone for formatFullDate function
      option.setAttribute("data-original-timezone", details.timeZone);  // Keep the original timezone too if needed
      option.textContent = userTimeString;
      selectEl.appendChild(option);
    });

    // Simple function to get next session date
    function getNextSessionDate(weekdayName, timeStr, periodStr, timeZoneStr) {
      // Map weekday names to numbers
      const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const targetDay = weekdays.indexOf(weekdayName);

      // Parse time
      const [hours, minutes] = timeStr.split(":").map(Number);

      // Convert to 24-hour format
      let hour24 = hours;
      if (periodStr.toUpperCase() === "PM" && hours < 12) hour24 += 12;
      if (periodStr.toUpperCase() === "AM" && hours === 12) hour24 = 0;

      // Get current date
      const now = new Date();
      const currentDayOfWeek = now.getDay();

      // Calculate days to add
      let daysToAdd = (targetDay - currentDayOfWeek + 7) % 7;

      // If it's the target day, check if the time has passed
      if (daysToAdd === 0) {
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();

        if (currentHour > hour24 || (currentHour === hour24 && currentMinute >= minutes)) {
          daysToAdd = 7; // Schedule for next week
        }
      }

      // Create the next session date
      const sessionDate = new Date(now);
      sessionDate.setDate(sessionDate.getDate() + daysToAdd);
      sessionDate.setHours(hour24, minutes, 0, 0);

      return sessionDate; // Return the date directly without timezone adjustments
    }

    // For countdown timer, use the first upcoming session
    if (sessionsWithDates.length > 0) {
      const nextSession = new Date(sessionsWithDates[0].nextDate.toISOString()); // Ensure UTC

      // Update the countdown
      function updateCountdown() {
        const now = new Date(); // Current time in user's local timezone
        const nowUTC = new Date(now.toISOString()); // Convert to UTC
        const timeLeft = nextSession.getTime() - nowUTC.getTime(); // Time difference in milliseconds

        if (timeLeft <= 0) {
          // Time has passed
          daysSpan.textContent = "0";
          hoursSpan.textContent = "0";
          minutesSpan.textContent = "0";
          secondsSpan.textContent = "0";
          return;
        }

        const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
        const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

        daysSpan.textContent = days.toString();
        hoursSpan.textContent = hours.toString();
        minutesSpan.textContent = minutes.toString();
        secondsSpan.textContent = seconds.toString();
      }

      // Initial update and set interval
      updateCountdown();
      setInterval(updateCountdown, 1000);
    }

    // Phone input formatting
    if (phoneInput) {
      let lastValue = "";
      let isDeleting = false;
      
      phoneInput.addEventListener("keydown", (e) => {
        const input = e.target as HTMLInputElement;
        lastValue = input.value;
        // Detect if user is deleting
        isDeleting = e.key === "Backspace" || e.key === "Delete";
      });

      phoneInput.addEventListener("input", (e) => {
        const input = e.target as HTMLInputElement;
        let value = input.value.replace(/\D/g, ""); // Remove non-digits
        
        // If user is deleting and the current value length is less than last value length,
        // don't add formatting until they start typing again
        if (isDeleting && input.value.length < lastValue.length) {
          // Just clean the value and set it without formatting
          if (value.length === 0) {
            input.value = "";
            return;
          }
          // Allow partial numbers without full formatting when deleting
          if (value.length <= 1) {
            input.value = value;
            return;
          }
        }
        
        // Add country code if not present
        if (!value.startsWith("1") && value.length > 0) {
          value = "1" + value;
        }
        
        // Format the number
        let formatted = "";
        if (value.length >= 1) {
          formatted = "+1";
          if (value.length > 1) {
            formatted += " (";
            if (value.length > 4) {
              formatted += value.slice(1, 4) + ") ";
              if (value.length > 7) {
                formatted += value.slice(4, 7) + "-" + value.slice(7, 11);
              } else {
                formatted += value.slice(4, 7);
              }
            } else {
              formatted += value.slice(1);
            }
          }
        }
        
        input.value = formatted;
      });
    }

    // Form submission
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      signupError.textContent = "";
      (buttonText as HTMLElement).style.display = "none";
      (loader as HTMLElement).style.display = "inline-block";
      (submitButton as HTMLButtonElement).disabled = true;

      const formData = new FormData(form);
      const investIntent = formData.get("invest_intent");
      if (investIntent) {
        localStorage.setItem(
          "invest_intent",
          typeof investIntent === "string" ? investIntent : ""
        );
      }
      const selectedOption = selectEl.querySelector("option:checked");
      const isoDateUTC = selectedOption.getAttribute("data-date");
      const sessionValue = selectedOption.value;
      const sessionDetails = JSON.parse(sessionValue);
      const sessionId = sessionDetails.id;

      const sessionTimeZone = sessionDetails.timeZone; // e.g., "America/New_York"
      const payload = {
        session: sessionId,
        first_name: formData.get("first_name"),
        last_name: formData.get("last_name"),
        email: formData.get("email"),
        phone_number: (() => {
          const val = formData.get("phone_number");
          return typeof val === "string" ? val.replace(/\D/g, "").replace(/^1/, "") : "";
        })(),
        invest_intent: formData.get("invest_intent"),
        bot_field: formData.get("bot-field"),
        date: isoDateUTC,
        fullDate: getFullDateString(isoDateUTC, sessionTimeZone) // e.g. "Wednesday, June 26 at 1:30 PM ET"
      };

      console.log("Payload being sent:", payload);

      try {
        const res = await fetch("/api/webinar-registration", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          signupError.textContent = "Registration failed. Please try again.";
          (buttonText as HTMLElement).style.display = "";
          (loader as HTMLElement).style.display = "none";
          (submitButton as HTMLButtonElement).disabled = false;
          return;
        }
        window.location.href = "/webinar-thank-you";
      } catch (err) {
        signupError.textContent = "An error occurred during registration.";
        (buttonText as HTMLElement).style.display = "";
        (loader as HTMLElement).style.display = "none";
        (submitButton as HTMLButtonElement).disabled = false;
      }
    });

    function formatFullDate(dateObj, timeZone) {
      const options: Intl.DateTimeFormatOptions = {
        weekday: "long",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        timeZone: timeZone,
        hour12: true,
        timeZoneName: "short"
      };
      const parts = new Intl.DateTimeFormat("en-US", options).formatToParts(dateObj);
      const weekday = parts.find(p => p.type === "weekday").value;
      const month = parts.find(p => p.type === "month").value;
      const day = ordinalSuffix(parts.find(p => p.type === "day").value);
      const hour = parts.find(p => p.type === "hour").value;
      const minute = parts.find(p => p.type === "minute").value;
      const period = parts.find(p => p.type === "dayPeriod").value;
      const tzName = parts.find(p => p.type === "timeZoneName").value;
      return `${weekday}, ${month} ${day} at ${hour}:${minute} ${period} ${tzName}`;
    }

    function ordinalSuffix(day) {
      const d = parseInt(day, 10);
      if (d > 3 && d < 21) return `${d}th`;
      switch (d % 10) {
        case 1: return `${d}st`;
        case 2: return `${d}nd`;
        case 3: return `${d}rd`;
        default: return `${d}th`;
      }
    }

    function toUserTimezoneIso(isoUtcString) {
      const date = new Date(isoUtcString);

      // Get user's timezone offset in minutes (e.g., -240 for EDT)
      const tzOffsetMinutes = date.getTimezoneOffset();
      const offsetHours = Math.floor(Math.abs(tzOffsetMinutes) / 60);
      const offsetMinutes = Math.abs(tzOffsetMinutes) % 60;
      const sign = tzOffsetMinutes > 0 ? "-" : "+";

      // Get local date/time parts
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");

      // Format as ISO string with offset
      return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
    }

    function getFullDateString(isoDateUTC, sessionTimeZone) {
      const date = new Date(isoDateUTC);

      const options = {
        weekday: "long",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
        timeZone: sessionTimeZone, // <-- Use session's timezone!
        timeZoneName: "short"
      };

      return date.toLocaleString("en-US", options);
    }
  });
});
</script>