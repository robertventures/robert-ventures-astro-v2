---

---

<style>
    .time {
        display: flex;
        justify-content: space-around;

        margin-top: 1rem;
        margin-bottom: 1rem;
    }

    .time div {
        font-weight: 600;
    }
    .form {
        max-width: 366px;

        margin: 0 auto;
    }

    .form-block {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        margin: 0 auto;

        flex-direction: column;
        gap: 0.75rem;

        width: 100%;
        box-sizing: border-box;

        margin-bottom: 1.25rem;
    }

    .name {
        display: flex;
        gap: 0.75rem;
        width: 100%;
    }

    input,
    select {
        border: none;
        flex-grow: 1; /* Allow the input to grow */
        border: 1px solid #afb5bc;
        padding: 1rem 0.75rem;
        width: 100%;
        box-sizing: border-box;

        border-radius: 0.75rem;
    }

    input::placeholder,
    select:invalid {
        color: #737373;
        opacity: 1;
    }

    select {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-color: #fff;
        border: 1px solid #afb5bc;
        width: 100%;

        color: #737373;
    }
    select:required:not(:invalid) {
        color: #1d1d1f;
    }

    button {
        background-color: #5028ff;
        border: none;
        color: #fff;
        border-radius: 0.75rem;

        padding: 1rem 0.75rem;

        font-size: 1.125rem;
        font-weight: 500;

        width: 100%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    .signup-error {
        display: none;
        color: red;
        text-align: center;
        margin-top: 0.5rem;
    }

    .loader {
        border: 2px solid #ffffff80; /* semi-transparent white */
        border-top: 2px solid #fff;  /* solid white for the spinner */
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        display: none;
        margin-left: 0.5rem;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }
        100% {
            transform: rotate(360deg);
        }
    }

    @media only screen and (min-width: 990px) {
        .account {
            max-width: none;
        }
    }
</style>

<div class="form">
    <form class="form-cta">
        <h3>Next session in:</h3>
        <div class="time">
            <div class="days">
                <span>0</span>
                <p>days</p>
            </div>
            <div class="hours">
                <span>0</span>
                <p>hours</p>
            </div>
            <div class="minutes">
                <span>0</span>
                <p>minutes</p>
            </div>
            <div class="seconds">
                <span>0</span>
                <p>seconds</p>
            </div>
        </div>
        <div class="form-block">
            <select name="session" required>
                <option value="" disabled selected>Select an upcoming session</option>
            </select>
            <div class="name">
                <input
                    type="text"
                    name="first_name"
                    placeholder="First Name"
                    required
                    class="email-input"
                />
                <input
                    type="text"
                    name="last_name"
                    placeholder="Last Name"
                    required
                    class="email-input"
                />
            </div>
            <input
                type="email"
                name="email"
                placeholder="Enter Your Email"
                required
                class="email-input"
            />
            <input
                type="tel"
                name="phone_number"
                placeholder="Phone Number"
                required
            />
            <select name="invest_intent" required>
                <option disabled selected>How much are you looking to invest?</option>
                <option value="1000">1k</option>
                <option value="5000">5k</option>
                <option value="10000">10k</option>
                <option value="25000">25k</option>
                <option value="50000">50k</option>
                <option value="100000">100k+</option>
            </select>
            <input
                type="text"
                name="bot-field"
                class="bot-field"
                style="display: none;"
            />
        </div>
        <button type="submit">
          <span class="button-text">REGISTER NOW</span>
          <span class="loader" style="display: none;"></span>
        </button>
        <p class="signup-error"></p>
    </form>
</div>

<script>
window.addEventListener("DOMContentLoaded", async () => {
  // Fetch webinar data once
  let data;
  try {
    const response = await fetch("/api/webinar-data", { cache: "no-store" });
    if (!response.ok) {
      console.error("Failed to fetch webinar data:", response.statusText);
      return;
    }
    data = await response.json();
  } catch (err) {
    console.error("An error occurred while fetching webinar data:", err);
    return;
  }

  // For each form instance on the page
  document.querySelectorAll(".form").forEach((formContainer) => {
    const form = formContainer.querySelector("form.form-cta") as HTMLFormElement;
    const selectEl = form.querySelector("select[name='session']");
    const phoneInput = form.querySelector("input[name='phone_number']");
    const daysSpan = formContainer.querySelector(".days span");
    const hoursSpan = formContainer.querySelector(".hours span");
    const minutesSpan = formContainer.querySelector(".minutes span");
    const secondsSpan = formContainer.querySelector(".seconds span");
    const signupError = form.querySelector(".signup-error");
    const submitButton = form.querySelector("button[type='submit']");
    const buttonText = submitButton.querySelector(".button-text");
    const loader = submitButton.querySelector(".loader");

    // Populate session select
    const sessions = data.results.filter((item) => {
      try {
        const parsed = JSON.parse(item.id);
        return parsed && parsed.type === "ongoing";
      } catch {
        return false;
      }
    });
    
    // Calculate next occurrence for each session and prepare data for sorting
    const sessionsWithDates = sessions.map(session => {
      const details = JSON.parse(session.id);
      const nextDate = computeSessionDate(details.day, `${details.time} ${details.period}`, details.timeZone);
      return {
        session: session,
        nextDate: nextDate
      };
    });
    
    // Sort sessions by their next occurrence date
    sessionsWithDates.sort((a, b) => a.nextDate.getTime() - b.nextDate.getTime());
    
    selectEl.innerHTML = '<option value="" disabled selected>Select an upcoming session</option>';
    
    // Add sorted sessions to dropdown
    sessionsWithDates.forEach(item => {
      const session = item.session;
      const nextDate = item.nextDate;
      const details = JSON.parse(session.id);
      
      // Convert session time to user's local timezone for display
      const userLocalTime = new Date(nextDate.toLocaleString("en-US", { timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone }));
      
      // Format the time in user's timezone
      const timeOptions: Intl.DateTimeFormatOptions = {
        weekday: 'long',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
      };
      
      const userTimeString = nextDate.toLocaleString("en-US", timeOptions);
      
      const option = document.createElement("option");
      option.value = session.id;
      option.setAttribute("data-date", nextDate.toISOString());
      option.setAttribute("data-timezone", details.timeZone);
      
      // Display the session with time converted to user's timezone
      option.textContent = `${userTimeString} (Your Time)`;
      selectEl.appendChild(option);
    });

    // Timer logic
    function getNextSessionDate(sessions) {
      let closest = null;
      console.log(sessions)
      sessions.forEach(session => {
        const details = JSON.parse(session.id);
        const date = computeSessionDate(details.day, `${details.time} ${details.period}`, details.timeZone);
        if (!closest || date < closest) closest = date;
      });
      return closest;
    }

    function computeSessionDate(weekdayName, timeStr, timeZone) {
      const daysOfWeek = { Sunday: 0, Monday: 1, Tuesday: 2, Wednesday: 3, Thursday: 4, Friday: 5, Saturday: 6 };
      const targetDay = daysOfWeek[weekdayName];

      // Parse the time string
      const [time, period] = timeStr.split(" ");
      let [hours, minutes] = time.split(":").map(Number);
      if (period === "PM" && hours !== 12) hours += 12;
      if (period === "AM" && hours === 12) hours = 0;

      // Get current date and time
      const now = new Date();
      const today = now.getDay();
      
      // Calculate days until next occurrence
      let daysUntil = (targetDay - today + 7) % 7;
      if (daysUntil === 0) {
        // If it's today, check if the time has passed
        const sessionTime = new Date();
        sessionTime.setHours(hours, minutes, 0, 0);
        
        // Convert session time to user's timezone for comparison
        const sessionInTz = new Date(sessionTime.toLocaleString("en-US", { timeZone }));
        const nowInTz = new Date(now.toLocaleString("en-US", { timeZone }));
        
        if (sessionInTz <= nowInTz) {
          daysUntil = 7; // Move to next week
        }
      }

      // Create the session date in the session's timezone
      const sessionDate = new Date(now);
      sessionDate.setDate(sessionDate.getDate() + daysUntil);
      sessionDate.setHours(hours, minutes, 0, 0);
      
      // Convert to user's local time for accurate countdown
      const sessionInUserTz = new Date(sessionDate.toLocaleString("en-US", { timeZone }));
      const userTzOffset = now.getTimezoneOffset() * 60000;
      const sessionTzOffset = sessionInUserTz.getTimezoneOffset() * 60000;
      
      return new Date(sessionDate.getTime() + (sessionTzOffset - userTzOffset));
    }

    function updateCountdown(targetDate) {
      const now = new Date();
      const target = targetDate instanceof Date ? targetDate : new Date(targetDate);
      const dist = target.getTime() - now.getTime();
      
      if (dist < 0) {
        // Session has passed, find the next one
        if (daysSpan) daysSpan.textContent = "0";
        if (hoursSpan) hoursSpan.textContent = "0";
        if (minutesSpan) minutesSpan.textContent = "0";
        if (secondsSpan) secondsSpan.textContent = "0";
        return;
      }
      
      const d = Math.floor(dist / (1000 * 60 * 60 * 24));
      const h = Math.floor((dist % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const m = Math.floor((dist % (1000 * 60 * 60)) / (1000 * 60));
      const s = Math.floor((dist % (1000 * 60)) / 1000);
      
      if (daysSpan) daysSpan.textContent = String(d);
      if (hoursSpan) hoursSpan.textContent = String(h);
      if (minutesSpan) minutesSpan.textContent = String(m);
      if (secondsSpan) secondsSpan.textContent = String(s);
    }

    const nextSessionDate = getNextSessionDate(sessions);
    if (nextSessionDate) {
      updateCountdown(nextSessionDate);
      setInterval(() => updateCountdown(nextSessionDate), 1000);
    }

    // Phone input formatting
    if (phoneInput) {
      let lastValue = "";
      let isDeleting = false;
      
      phoneInput.addEventListener("keydown", (e) => {
        const input = e.target as HTMLInputElement;
        lastValue = input.value;
        // Detect if user is deleting
        isDeleting = e.key === "Backspace" || e.key === "Delete";
      });

      phoneInput.addEventListener("input", (e) => {
        const input = e.target as HTMLInputElement;
        let value = input.value.replace(/\D/g, ""); // Remove non-digits
        
        // If user is deleting and the current value length is less than last value length,
        // don't add formatting until they start typing again
        if (isDeleting && input.value.length < lastValue.length) {
          // Just clean the value and set it without formatting
          if (value.length === 0) {
            input.value = "";
            return;
          }
          // Allow partial numbers without full formatting when deleting
          if (value.length <= 1) {
            input.value = value;
            return;
          }
        }
        
        // Add country code if not present
        if (!value.startsWith("1") && value.length > 0) {
          value = "1" + value;
        }
        
        // Format the number
        let formatted = "";
        if (value.length >= 1) {
          formatted = "+1";
          if (value.length > 1) {
            formatted += " (";
            if (value.length > 4) {
              formatted += value.slice(1, 4) + ") ";
              if (value.length > 7) {
                formatted += value.slice(4, 7) + "-" + value.slice(7, 11);
              } else {
                formatted += value.slice(4, 7);
              }
            } else {
              formatted += value.slice(1);
            }
          }
        }
        
        input.value = formatted;
      });
    }

    // Form submission
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      signupError.textContent = "";
      (buttonText as HTMLElement).style.display = "none";
      (loader as HTMLElement).style.display = "inline-block";
      (submitButton as HTMLButtonElement).disabled = true;

      const formData = new FormData(form);
      const investIntent = formData.get("invest_intent");
      if (investIntent) {
        localStorage.setItem(
          "invest_intent",
          typeof investIntent === "string" ? investIntent : ""
        );
      }
      const selectedOption = selectEl.querySelector("option:checked");
      const isoDate = selectedOption.getAttribute("data-date");
      const tz = selectedOption.getAttribute("data-timezone");
      const sessionId = JSON.parse((selectedOption as HTMLOptionElement).value).id;
      const fullDate = formatFullDate(new Date(isoDate), tz);

      const payload = {
        session: sessionId,
        first_name: formData.get("first_name"),
        last_name: formData.get("last_name"),
        email: formData.get("email"),
        phone_number: (() => {
          const val = formData.get("phone_number");
          return typeof val === "string" ? val.replace(/\D/g, "").replace(/^1/, "") : "";
        })(),
        invest_intent: formData.get("invest_intent"),
        bot_field: formData.get("bot-field"),
        date: isoDate,
        fullDate: fullDate
      };

      try {
        const res = await fetch("/api/webinar-registration", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          signupError.textContent = "Registration failed. Please try again.";
          (buttonText as HTMLElement).style.display = "";
          (loader as HTMLElement).style.display = "none";
          (submitButton as HTMLButtonElement).disabled = false;
          return;
        }
        window.location.href = "/webinar-thank-you";
      } catch (err) {
        signupError.textContent = "An error occurred during registration.";
        (buttonText as HTMLElement).style.display = "";
        (loader as HTMLElement).style.display = "none";
        (submitButton as HTMLButtonElement).disabled = false;
      }
    });

    function formatFullDate(dateObj, timeZone) {
      const options: Intl.DateTimeFormatOptions = {
        weekday: "long",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        timeZone: timeZone,
        hour12: true,
        timeZoneName: "short"
      };
      const parts = new Intl.DateTimeFormat("en-US", options).formatToParts(dateObj);
      const weekday = parts.find(p => p.type === "weekday").value;
      const month = parts.find(p => p.type === "month").value;
      const day = ordinalSuffix(parts.find(p => p.type === "day").value);
      const hour = parts.find(p => p.type === "hour").value;
      const minute = parts.find(p => p.type === "minute").value;
      const period = parts.find(p => p.type === "dayPeriod").value;
      const tzName = parts.find(p => p.type === "timeZoneName").value;
      return `${weekday}, ${month} ${day} at ${hour}:${minute} ${period} ${tzName}`;
    }

    function ordinalSuffix(day) {
      const d = parseInt(day, 10);
      if (d > 3 && d < 21) return `${d}th`;
      switch (d % 10) {
        case 1: return `${d}st`;
        case 2: return `${d}nd`;
        case 3: return `${d}rd`;
        default: return `${d}th`;
      }
    }
  });
});
</script>