---
import Image from "astro/components/Image.astro";
import Opener from "../images/svg/opener.svg";
import usFlag from "../images/usflag.png";

// Component configuration
const formConfig = {
  maxSessions: 2,
  defaultTimezone: "America/New_York",
  estOffset: -5
};

// Analytics events
const analyticsEvents = {
  registerNow: { ga4: 'register_now', clarity: 'registerNow' },
  webinarRegistered: { ga4: 'webinar_registered', clarity: 'webinarRegistered' }
};
---

<div class="form">
  <form class="form-cta">
    <div class="form-block">
      <div class="name">
        <input
          type="text"
          name="full_name"
          placeholder="Full Name"
          required
          class="email-input"
        />
      </div>
      <input
        type="email"
        name="email"
        placeholder="Enter Your Email"
        required
        class="email-input"
      />
      <div class="phone-input-wrapper">
        <Image src={usFlag} alt="US Flag" height={22} class="phone-flag" />
        <input
          type="tel"
          name="phone_number"
          placeholder="(555) 555-5555"
          required
          maxlength="14"
          inputmode="numeric"
          autocomplete="tel-national"
        />
      </div>

      <div class="select-container">
        <select name="invest_intent" required>
          <option value="" disabled selected>Estimate Amount to Invest?</option>
          <option value="1000">$1,000</option>
          <option value="5000">$5,000</option>
          <option value="10000">$10,000</option>
          <option value="25000">$25,000</option>
          <option value="50000">$50,000</option>
          <option value="100000">$100,000+</option>
        </select>
        <Opener />
      </div>

      <div class="select-container">
        <select name="session" required>
          <option value="" disabled selected>Select an Upcoming Session</option>
        </select>
        <Opener />
      </div>

      <input
        type="text"
        name="bot-field"
        class="bot-field"
        style="display: none;"
      />
    </div>
    <button type="submit">
      <span class="button-text">Register Now</span>
      <span class="loader"></span>
    </button>
    <p class="signup-error"></p>
  </form>
</div>

<style>
  .form {
    width: 100%;
    max-width: 100%;
    margin: 0;
    background: transparent;
    border-radius: 1rem;
    box-shadow: none;
    padding: 0;
  }

  .form-block {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    margin: 0 auto;
    flex-direction: column;
    gap: 12px;
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 32px;
  }

  .name {
    display: flex;
    gap: 0.75rem;
    width: 100%;
  }

  .select-container {
    position: relative;
    width: 100%;
  }

  .select-container svg {
    position: absolute;
    right: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    z-index: 1;
  }

  input {
    border: 1px solid #30414D;
    flex-grow: 1;
    background-color: #152429;
    padding: 1rem;
    width: 100%;
    box-sizing: border-box;
    border-radius: 0.75rem;
    color: #E1EEEA;
    transition: border-color 0.2s ease;
    font-size: 1rem;
  }

  select {
    border: 1px solid #30414D;
    flex-grow: 1;
    background-color: #152429;
    padding: 1rem;
    width: 100%;
    box-sizing: border-box;
    border-radius: 0.75rem;
    color: #E1EEEA;
    transition: border-color 0.2s ease;
    font-size: 1rem;
  }

  input:focus,
  select:focus {
    outline: none;
    border: 1px solid #D3FBD8;
  }

  input::placeholder {
    color: #8a9ca3;
    opacity: 1;
  }

  select:invalid {
    color: #8a9ca3;
    opacity: 1;
  }

  select {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-color: #152429;
    border: 1px solid #30414D;
    width: 100%;
    color: #E1EEEA;
  }
  
  select:required:not(:invalid) {
    color: #E1EEEA;
  }

  select option {
    background-color: #152429;
    color: #E1EEEA;
  }

  select option[disabled] {
    color: #8a9ca3 !important;
  }

  button {
    background-color: #D3FBD8;
    border: 1px solid #D3FBD8;
    color: #152429;
    border-radius: 8px;
    padding: 12px;
    font-size: 18px;
    font-weight: 600;
    line-height: 100%;
    font-family: 'Roboto', sans-serif;
    width: 100%;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    cursor: pointer;
    transition: background-color 0.2s ease, border-color 0.2s ease;
    text-align: center;
    box-sizing: border-box;
    margin: 0;
  }

  button:active {
    background-color: #9ebca2;
    border-color: #9ebca2;
  }

  button:hover {
    background-color: #b8f5c4;
    border-color: #b8f5c4;
  }

  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .signup-error {
    display: none;
    color: red;
    text-align: center;
    margin-top: 0.5rem;
  }

  .loader {
    border: 2px solid #ffffff80;
    border-top: 2px solid #fff;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    animation: spin 1s linear infinite;
    display: none;
    margin-left: 0.5rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .phone-input-wrapper {
    position: relative;
    width: 100%;
  }
  
  .phone-input-wrapper .phone-flag {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    width: auto;
    height: 22px;
    object-fit: contain;
    aspect-ratio: 22/16;
    pointer-events: none;
    z-index: 2;
    margin-right: 12px;
  }
  
  .phone-input-wrapper input[type="tel"] {
    padding-left: calc(22px + 12px + 1rem) !important;
    background-color: #152429;
    color: #E1EEEA;
  }

  .phone-input-wrapper input[type="tel"]:focus {
    border: 1px solid #D3FBD8;
  }

  @media only screen and (min-width: 990px) {
    .form {
      width: 100%;
      max-width: 100%;
    }
  }
</style>

<script>
  // Utility functions
  const utils = {
    // Format phone number
    formatPhoneNumber: (value) => {
      const digits = value.replace(/\D/g, "");
      if (digits.length <= 3) return digits;
      if (digits.length <= 6) return `(${digits.slice(0, 3)}) ${digits.slice(3)}`;
      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
    },

    // Get timestamp in user's timezone with correct timezone offset
    getESTTimestamp: (userTimezone = "America/New_York") => {
      const now = new Date();
      
      // Create a date in user's timezone to get the correct offset
      const userLocalTime = new Date(now.toLocaleString("en-US", { timeZone: userTimezone }));
      const utcTime = new Date(now.toLocaleString("en-US", { timeZone: "UTC" }));
      
      // Calculate the offset in minutes
      const offsetMinutes = userLocalTime.getTime() - utcTime.getTime();
      const offsetHours = Math.floor(Math.abs(offsetMinutes) / (1000 * 60 * 60));
      const offsetSign = offsetMinutes >= 0 ? '+' : '-';
      
      const year = userLocalTime.getFullYear();
      const month = String(userLocalTime.getMonth() + 1).padStart(2, '0');
      const day = String(userLocalTime.getDate()).padStart(2, '0');
      const hours = String(userLocalTime.getHours()).padStart(2, '0');
      const minutes = String(userLocalTime.getMinutes()).padStart(2, '0');
      const seconds = String(userLocalTime.getSeconds()).padStart(2, '0');
      
      return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${offsetSign}0${offsetHours}:00`;
    },

    // Format time left
    formatTimeLeft: (targetDate) => {
      const now = new Date();
      let diff = targetDate.getTime() - now.getTime();
      if (diff <= 0) return "(Started)";
      
      const days = Math.floor(diff / (1000 * 60 * 60 * 24));
      diff -= days * (1000 * 60 * 60 * 24);
      const hours = Math.floor(diff / (1000 * 60 * 60));
      diff -= hours * (1000 * 60 * 60);
      const minutes = Math.floor(diff / (1000 * 60));
      
      let result = [];
      if (days > 0) result.push(days + (days === 1 ? " day" : " days"));
      if (hours > 0) result.push(hours + (hours === 1 ? " hour" : " hours"));
      if (minutes > 0 && days === 0) result.push(minutes + (minutes === 1 ? " minute" : " minutes"));
      
      return result.length ? "In " + result.join(" ") : "Soon";
    },

    // Trigger analytics events
    triggerEvent: (eventName, clarityEventName, eventData = {}) => {
      if ((window as any).dataLayer) {
        (window as any).dataLayer.push({ 
          'event': eventName, 
          ...eventData 
        });
        console.log('GA4 event triggered: ' + eventName, eventData);
      }
      
      if (typeof (window as any).clarity === 'function') {
        // Set custom tags for Clarity session so you can filter recordings by these values
        Object.keys(eventData).forEach(key => {
          (window as any).clarity('set', key, eventData[key]);
        });
        
        (window as any).clarity('event', clarityEventName);
        console.log('Clarity event triggered: ' + clarityEventName);
      }
    }
  };

  // Main webinar form functionality
  let webinarData = null;
  let countdownIntervals = new Map(); // Store intervals for cleanup

  window.addEventListener("DOMContentLoaded", async () => {
    // Setup phone formatting IMMEDIATELY (independent of API)
    setupAllPhoneInputs();
    
    await loadAndInitializeWebinarData();
    
    // Refresh webinar data every 5 minutes to ensure we have the latest sessions
    setInterval(async () => {
      await loadAndInitializeWebinarData();
    }, 5 * 60 * 1000); // 5 minutes
  });

  // Setup phone formatting for all phone inputs on page
  function setupAllPhoneInputs() {
    const phoneInputs = document.querySelectorAll("input[name='phone_number']");
    
    phoneInputs.forEach((input) => {
      const phoneInput = input as HTMLInputElement;
      if (phoneInput.dataset.phoneInitialized === "true") return;
      
      phoneInput.addEventListener("input", (e) => {
        const target = e.target as HTMLInputElement;
        if (!target) return;
        
        // Get raw digits only
        let digits = target.value.replace(/\D/g, "");
        
        // Limit to 10 digits (US phone number)
        if (digits.length > 10) {
          digits = digits.slice(0, 10);
        }
        
        // Format the phone number: (XXX) XXX-XXXX
        let formatted = "";
        if (digits.length > 0) {
          if (digits.length <= 3) {
            formatted = "(" + digits;
          } else if (digits.length <= 6) {
            formatted = "(" + digits.slice(0, 3) + ") " + digits.slice(3);
          } else {
            formatted = "(" + digits.slice(0, 3) + ") " + digits.slice(3, 6) + "-" + digits.slice(6);
          }
        }
        
        target.value = formatted;
      });
      
      // Block non-numeric input
      phoneInput.addEventListener("keypress", (e) => {
        if (!/[0-9]/.test(e.key)) {
          e.preventDefault();
        }
      });
      
      // Handle paste - format pasted content
      phoneInput.addEventListener("paste", (e) => {
        e.preventDefault();
        const target = e.target as HTMLInputElement;
        const clipboardData = e.clipboardData || (window as any).clipboardData;
        const pastedText = clipboardData.getData("text");
        let digits = pastedText.replace(/\D/g, "").slice(0, 10);
        
        let formatted = "";
        if (digits.length > 0) {
          if (digits.length <= 3) {
            formatted = "(" + digits;
          } else if (digits.length <= 6) {
            formatted = "(" + digits.slice(0, 3) + ") " + digits.slice(3);
          } else {
            formatted = "(" + digits.slice(0, 3) + ") " + digits.slice(3, 6) + "-" + digits.slice(6);
          }
        }
        
        target.value = formatted;
      });
      
      phoneInput.dataset.phoneInitialized = "true";
      phoneInput.setAttribute("maxlength", "14");
    });
  }

  async function loadAndInitializeWebinarData() {
    try {
      // Fetch webinar data
      const response = await fetch("/api/webinar-data", { cache: "no-store" });
      if (!response.ok) {
        console.error("Failed to fetch webinar data:", response.statusText);
        return;
      }
      const data = await response.json();

      // Store the data globally
      webinarData = data;

      // Initialize form
      initializeForm(data);
    } catch (err) {
      console.error("An error occurred while fetching webinar data:", err);
    }
  }

  function initializeForm(data) {
    document.querySelectorAll(".form").forEach((formContainer, index) => {
      const form = formContainer.querySelector("form.form-cta");
      if (!form) return;

      // Add unique form ID for interval management
      const formContainerEl = formContainer as HTMLElement;
      if (!formContainerEl.dataset.formId) {
        formContainerEl.dataset.formId = `form-${index}`;
      }

      const elements = getFormElements(form, formContainer);
      if (!elements) return;

      const { selectEl, phoneInput, timeElements, signupError, submitButton, buttonText, loader } = elements;

      // Populate sessions dropdown
      populateSessionsDropdown(selectEl, data);

      // Initialize countdown timer (only if time elements exist)
      if (timeElements) {
        initializeCountdown(timeElements, data);
      }

      // Phone input formatting is handled by setupAllPhoneInputs() on page load

      // Setup form submission (only once)
      const formEl = form as HTMLFormElement;
      if (!formEl.dataset.initialized) {
        setupFormSubmission(form, elements);
        formEl.dataset.initialized = 'true';
      }

      // Setup form started tracking (fires once on first interaction with any form field)
      if (!formEl.dataset.formStartedTracked) {
        let formStartedFired = false;
        
        form.addEventListener('focusin', (e) => {
          if (formStartedFired) return;
          
          // Only trigger for actual form input fields
          const target = e.target as HTMLElement;
          if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA') {
            formStartedFired = true;
            
            // Push to dataLayer
            if ((window as any).dataLayer) {
              (window as any).dataLayer.push({
                'event': 'webinar_form_started'
              });
              console.log('GA4 event triggered: webinar_form_started');
            }
            
            // Send to Clarity
            if (typeof (window as any).clarity === 'function') {
              (window as any).clarity('event', 'webinarFormStarted');
              console.log('Clarity event triggered: webinarFormStarted');
            }
          }
        });
        
        formEl.dataset.formStartedTracked = 'true';
      }
    });
  }

  function getFormElements(form, formContainer) {
    const selectEl = form.querySelector("select[name='session']");
    const investSelectEl = form.querySelector("select[name='invest_intent']");
    const phoneInput = form.querySelector("input[name='phone_number']");
    const signupError = form.querySelector(".signup-error");
    const submitButton = form.querySelector("button[type='submit']");
    const buttonText = submitButton?.querySelector(".button-text");
    const loader = submitButton?.querySelector(".loader");

    // Required elements for form to work
    if (!selectEl || !investSelectEl || !signupError || !submitButton || !buttonText || !loader) {
      return null;
    }

    // Time elements are optional (may be commented out in some layouts)
    const sectionContent = formContainer.closest('.section-content');
    const daysSpan = sectionContent?.querySelector(".days span");
    const hoursSpan = sectionContent?.querySelector(".hours span");
    const minutesSpan = sectionContent?.querySelector(".minutes span");
    const secondsSpan = sectionContent?.querySelector(".seconds span");
    
    // Only include time elements if all of them exist
    const timeElements = (daysSpan && hoursSpan && minutesSpan && secondsSpan) 
      ? { daysSpan, hoursSpan, minutesSpan, secondsSpan }
      : null;

    return {
      selectEl,
      investSelectEl,
      phoneInput,
      timeElements,
      signupError,
      submitButton,
      buttonText,
      loader
    };
  }

  function populateSessionsDropdown(selectEl, data) {
    const userTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    
    // Clear and add default option
    selectEl.innerHTML = '<option value="" disabled selected>Select an Upcoming Session</option>';
    
    // STEP 1: Add the ON-DEMAND option first (uses separate webinar)
    if (data.onDemandAvailable) {
      const instantOption = document.createElement("option");
      instantOption.value = "instant";
      instantOption.setAttribute("data-date", "instant");
      instantOption.setAttribute("data-timezone", userTz);
      instantOption.setAttribute("data-is-instant", "true");
      instantOption.setAttribute("data-webinar-id", data.webinarIds?.onDemand || "");
      instantOption.textContent = "Watch Now - On Demand";
      selectEl.appendChild(instantOption);
    }
    
    // STEP 2: Get ongoing (scheduled) sessions
    const sessions = data.results.filter((item) => {
      try {
        const parsed = JSON.parse(item.id);
        return parsed && parsed.type === "ongoing";
      } catch {
        return false;
      }
    });

    const sessionsWithDates = sessions.map(session => {
      try {
        const details = JSON.parse(session.id);
        const nextDate = session.date ? new Date(session.date) : calculateNextSessionDate(details);
        return { session, nextDate };
      } catch (error) {
        console.error("Error processing session:", error);
        return null;
      }
    }).filter(Boolean).sort((a, b) => a.nextDate.getTime() - b.nextDate.getTime());

    // STEP 3: Add only the next 2 scheduled sessions
    sessionsWithDates.slice(0, 2).forEach((item) => {
      const { session, nextDate } = item;
      const details = JSON.parse(session.id);
      
      const weekday = nextDate.toLocaleString("en-US", { weekday: "short" });
      const month = nextDate.getMonth() + 1;
      const day = nextDate.getDate();
      const time = nextDate.toLocaleString("en-US", {
        hour: "numeric",
        minute: "2-digit",
        hour12: true,
      });
      
      const tzMatch = nextDate.toLocaleTimeString("en-US", { timeZoneName: "short" }).match(/GMT[+-]\d+/);
      const tzShort = tzMatch ? tzMatch[0] : nextDate.toLocaleString("en-US", { timeZoneName: "short" }).split(" ").pop();
      const timeLeftString = utils.formatTimeLeft(nextDate);
      
      const option = document.createElement("option");
      option.value = session.id;
      option.setAttribute("data-date", nextDate.toISOString());
      option.setAttribute("data-timezone", userTz);
      option.setAttribute("data-original-timezone", details.timeZone);
      option.setAttribute("data-is-instant", "false");
      option.setAttribute("data-webinar-id", data.webinarIds?.scheduled || "");
      option.textContent = `${weekday}, ${month}/${day}, ${time} ${tzShort} - ${timeLeftString}`;
      selectEl.appendChild(option);
    });
  }

  function calculateNextSessionDate(details) {
    const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const targetDay = weekdays.indexOf(details.day);
    const [hours, minutes] = details.time.split(":").map(Number);
    let hour24 = hours;
    if (details.period.toUpperCase() === "PM" && hours < 12) hour24 += 12;
    if (details.period.toUpperCase() === "AM" && hours === 12) hour24 = 0;

    const now = new Date();
    const currentTzTime = new Date(now.toLocaleString("en-US", {
      timeZone: details.timeZone || "America/New_York",
    }));

    const currentDay = currentTzTime.getDay();
    let daysToAdd = (targetDay - currentDay + 7) % 7;

    if (daysToAdd === 0) {
      const currentHour = currentTzTime.getHours();
      const currentMinute = currentTzTime.getMinutes();
      if (currentHour > hour24 || (currentHour === hour24 && currentMinute >= minutes)) {
        daysToAdd = 7;
      }
    }

    const sessionDate = new Date(currentTzTime);
    sessionDate.setDate(sessionDate.getDate() + daysToAdd);
    sessionDate.setHours(hour24, minutes, 0, 0);

    const sessionUTC = new Date(sessionDate.getTime() - sessionDate.getTimezoneOffset() * 60000);
    const tempDate = new Date(sessionDate.toISOString().slice(0, -1));
    const tzOffset = new Date(tempDate.toLocaleString("en-US", {
      timeZone: details.timeZone || "America/New_York",
    })).getTime() - tempDate.getTime();
    
    return new Date(sessionDate.getTime() - tzOffset);
  }

  function initializeCountdown(timeElements, data) {
    // Clear any existing interval for this form
    // Time elements are now siblings of .form, so find the form container via parent
    const timeContainer = timeElements.daysSpan.closest('.time') as HTMLElement;
    const parentSection = timeContainer?.parentElement;
    const formElement = parentSection?.querySelector('.form') as HTMLElement;
    const formId = formElement?.dataset?.formId || 'default';
    if (countdownIntervals.has(formId)) {
      clearInterval(countdownIntervals.get(formId));
    }

    const sessions = data.results.filter((item) => {
      try {
        const parsed = JSON.parse(item.id);
        return parsed && parsed.type === "ongoing";
      } catch {
        return false;
      }
    });

    if (sessions.length > 0) {
      // Use the same logic as the dropdown to find the next upcoming session
      const sessionsWithDates = sessions.map(session => {
        try {
          const details = JSON.parse(session.id);
          const nextDate = session.date ? new Date(session.date) : calculateNextSessionDate(details);
          return { session, nextDate };
        } catch (error) {
          console.error("Error processing session:", error);
          return null;
        }
      }).filter(Boolean).sort((a, b) => a.nextDate.getTime() - b.nextDate.getTime());

      if (sessionsWithDates.length > 0) {
        let currentSessionIndex = 0;
        
        function updateCountdown() {
          const now = new Date();
          
          // Check if current session has passed and switch to next one
          while (currentSessionIndex < sessionsWithDates.length) {
            const currentSession = sessionsWithDates[currentSessionIndex];
            const timeLeft = currentSession.nextDate.getTime() - now.getTime();
            
            if (timeLeft > 0) {
              // This session is still upcoming, use it
              break;
            } else {
              // This session has passed, move to next one
              currentSessionIndex++;
            }
          }
          
          // If we've gone through all sessions, show zeros
          if (currentSessionIndex >= sessionsWithDates.length) {
            timeElements.daysSpan.textContent = "0";
            timeElements.hoursSpan.textContent = "0";
            timeElements.minutesSpan.textContent = "0";
            timeElements.secondsSpan.textContent = "0";
            return;
          }
          
          const currentSession = sessionsWithDates[currentSessionIndex];
          const timeLeft = currentSession.nextDate.getTime() - now.getTime();

          const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
          const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

          timeElements.daysSpan.textContent = days.toString();
          timeElements.hoursSpan.textContent = hours.toString();
          timeElements.minutesSpan.textContent = minutes.toString();
          timeElements.secondsSpan.textContent = seconds.toString();
        }

        updateCountdown();
        const interval = setInterval(updateCountdown, 1000);
        countdownIntervals.set(formId, interval);
      }
    }
  }


  function setupFormSubmission(form, elements) {
    const { selectEl, investSelectEl, signupError, submitButton, buttonText, loader, phoneInput } = elements;

    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      signupError.textContent = "";
      buttonText.style.display = "none";
      loader.style.display = "inline-block";
      submitButton.disabled = true;

      // --- PHONE VALIDATION ---
      const phoneRaw = phoneInput.value.replace(/\D/g, "");
      // US phone: 10 digits, area code cannot start with 0 or 1
      if (!/^([2-9][0-9]{2})([2-9][0-9]{2})([0-9]{4})$/.test(phoneRaw)) {
        signupError.textContent = "Please enter a valid US phone number (10 digits, area code cannot start with 0 or 1).";
        signupError.style.display = "block";
        resetFormState(buttonText, loader, submitButton);
        phoneInput.focus();
        return;
      }
      signupError.style.display = "none";
      // --- END PHONE VALIDATION ---

      const formData = new FormData(form);
      const selectedOption = selectEl.querySelector("option:checked");
      const selectedInvest = investSelectEl && investSelectEl.value ? investSelectEl.value : "";
      
      if (!selectedOption) {
        signupError.textContent = "Please select a session.";
        resetFormState(buttonText, loader, submitButton);
        return;
      }

      if (!selectedInvest) {
        signupError.textContent = "Please select how much you are looking to invest.";
        resetFormState(buttonText, loader, submitButton);
        return;
      }

      // Persist selected investment amount
      try {
        localStorage.setItem("invest_intent", selectedInvest);
      } catch {}

      // Check if this is an instant (on-demand) session
      const isInstant = selectedOption.getAttribute("data-is-instant") === "true";
      
      let isoDateUTC: string;
      let sessionValue: string;
      let sessionDetails: any;
      
      if (isInstant) {
        // Handle instant/on-demand session
        isoDateUTC = "instant";
        sessionValue = "instant";
        sessionDetails = { type: "instant", timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };
      } else {
        // Handle scheduled sessions
        isoDateUTC = selectedOption.getAttribute("data-date") || "";
        sessionValue = selectedOption.value;

        if (!isoDateUTC || !sessionValue) {
          signupError.textContent = "Invalid session data.";
          resetFormState(buttonText, loader, submitButton);
          return;
        }

        try {
          sessionDetails = JSON.parse(sessionValue);
        } catch (error) {
          signupError.textContent = "Invalid session format.";
          resetFormState(buttonText, loader, submitButton);
          return;
        }
      }

      // Collect UTM parameters, prioritizing URL params, fallback to localStorage
      // Note: Google Ads params are mapped to UTM fields in userAttribution.js
      const utmParams = [
        "utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "utm_id"
      ];
      const urlParams = new URLSearchParams(window.location.search);
      const utmData: Partial<Record<"utm_source" | "utm_medium" | "utm_campaign" | "utm_content" | "utm_term" | "utm_id", string>> = {};
      utmParams.forEach(param => {
        let value = urlParams.get(param);
        if (!value) {
          try { value = localStorage.getItem(param) || undefined; } catch {}
        }
        if (value) utmData[param] = value;
      });

      // Get gclid (Google Click ID) - this is a standard GHL field
      let gclid = urlParams.get("gclid");
      if (!gclid) {
        try { gclid = localStorage.getItem("gclid") || undefined; } catch {}
      }

      // Device detection fallback
      function detectDeviceFromUA(ua) {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
        if (!isMobile) return "desktop";
        if (/iPhone|iPad|iPod/i.test(ua)) return "ios";
        if (/Android/i.test(ua)) return "android";
        return "android";
      }
      let deviceType;
      try { deviceType = localStorage.getItem("device_type"); } catch {}
      if (!deviceType) deviceType = detectDeviceFromUA(navigator.userAgent);

      // Provide top-level utm_campaign for systems expecting it
      const utmCampaignTop = utmData.utm_campaign || (() => { try { return localStorage.getItem("utm_campaign"); } catch { return null; } })();

      // Build Google Calendar URL from selected webinar date (skip for instant sessions)
      const webinarCalendarUrl = isInstant ? "" : buildGoogleCalendarUrl(isoDateUTC);

      // Get the webinar ID from the selected option
      const webinarId = selectedOption.getAttribute("data-webinar-id") || "";

      const payload = {
        session: isInstant ? "instant" : sessionDetails.id,
        name: formData.get("full_name"),
        email: formData.get("email"),
        phone_number: (() => {
          const val = formData.get("phone_number");
          return typeof val === "string" ? val.replace(/\D/g, "") : "";
        })(),
        invest_intent: formData.get("invest_intent"),
        bot_field: formData.get("bot-field"),
        date: isoDateUTC,
        fullDate: isInstant ? "Watch Now - On Demand" : getFullDateString(isoDateUTC, sessionDetails.timeZone),
        utm: utmData, // UTM fields (also contains mapped Google Ads data)
        gclid: gclid || undefined, // Google Click ID (standard GHL field)
        utm_campaign: utmCampaignTop || undefined,
        webinar_sign_up_date: utils.getESTTimestamp(selectedOption.getAttribute("data-timezone")),
        user_timezone: selectedOption.getAttribute("data-timezone"),
        user_ip: localStorage.getItem("userIP") || undefined,
        device_type: deviceType || undefined,
        webinar_test: 'webinar-ux_2025-07-21_v1',
        // Google Calendar URL for GHL (empty for instant sessions)
        webinar_calendar_url: webinarCalendarUrl,
        // Meta deduplication fields
        event_id: generateEventId(),
        fbp: getFbp(),
        fbc: getFbc(),
        // Flag to indicate instant session
        is_instant: isInstant,
        // Webinar ID for registration (different for on-demand vs scheduled)
        webinar_id: webinarId
      };

      console.log("Payload being sent:", payload);
      localStorage.setItem("webinar_sign_up_date", utils.getESTTimestamp(selectedOption.getAttribute("data-timezone")));

      try {
        const res = await fetch("/api/webinar-registration", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        
        if (!res.ok) {
          signupError.textContent = "Registration failed. Please try again.";
          resetFormState(buttonText, loader, submitButton);
          return;
        }
        
        const result = await res.json();
        if (result.ghl_contact_id) {
          localStorage.setItem("ghl_contact_id", result.ghl_contact_id);
          console.log("✅ GHL Contact ID saved:", result.ghl_contact_id);
        }
        
        const userEmail = formData.get("email");
        if (userEmail) {
          localStorage.setItem("userEmail", typeof userEmail === "string" ? userEmail : "");
        }
        
        // Identify the user in Microsoft Clarity using their email after successful registration
        try {
          const emailStr = typeof userEmail === "string" ? userEmail : "";
          if (emailStr && typeof (window as any).clarity === 'function') {
            (window as any).clarity('identify', emailStr);
          }
        } catch {}
        
        // Store full session details for calendar
        localStorage.setItem("webinarSession", JSON.stringify({
          title: sessionDetails.title || "Robert Ventures Webinar",
          date: isoDateUTC,
          timeZone: sessionDetails.timeZone,
          fullDate: isInstant ? "Watch Now - On Demand" : getFullDateString(isoDateUTC, sessionDetails.timeZone),
          email: formData.get("email"),
          name: formData.get("full_name"),
          isInstant: isInstant
        }));
        
        // Trigger analytics events
        utils.triggerEvent('webinar_registered', 'webinarRegistered', {
          invest_intent: formData.get("invest_intent"),
          session_date: isoDateUTC,
          session_type: isInstant ? "instant" : "scheduled"
        });

        // Fire Meta Pixel for all registrations with deduplication eventID
        try {
          (function(f,b,e,v,n,t,s){
            if ((f as any).fbq) return; n=(f as any).fbq=function(){ n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments); };
            if (!(f as any)._fbq) (f as any)._fbq=n; n.push=n; (n as any).loaded=!0; (n as any).version='2.0'; (n as any).queue=[]; t=b.createElement(e); (t as any).async=!0; (t as any).src=v; s=b.getElementsByTagName(e)[0]; s.parentNode.insertBefore(t,s);
          })(window, document, 'script', 'https://connect.facebook.net/en_US/fbevents.js');
          (window as any).fbq('init', '652212003052612');
          // Reuse the exact same event_id as the server-side CAPI call
          const eventId = (payload as any).event_id;
          (window as any).fbq('track', 'CompleteRegistration', {}, { eventID: eventId });
        } catch {}

        // Redirect to questions page after registration
        window.location.href = "/questions";
      } catch (err) {
        signupError.textContent = "An error occurred during registration.";
        resetFormState(buttonText, loader, submitButton);
      }
    });
  }

  function resetFormState(buttonText, loader, submitButton) {
    buttonText.style.display = "";
    loader.style.display = "none";
    submitButton.disabled = false;
  }

  function getFullDateString(isoDateUTC, sessionTimeZone) {
    const date = new Date(isoDateUTC);
    const options = {
      weekday: "long",
      month: "long",
      day: "numeric",
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
      timeZone: sessionTimeZone,
      timeZoneName: "short",
    } as Intl.DateTimeFormatOptions;
    return date.toLocaleString("en-US", options);
  }

  /**
   * Builds a Google Calendar URL from the selected webinar date
   * Format: https://calendar.google.com/calendar/render?action=TEMPLATE&text=Robert+Ventures+Investment+Webinar&dates={START}/{END}&details=Join+us+live+at+robertventures.com/webinar
   * Date format: YYYYMMDDTHHMMSS (30 minute duration)
   */
  function buildGoogleCalendarUrl(isoDateUTC: string): string {
    const startDate = new Date(isoDateUTC);
    const endDate = new Date(startDate.getTime() + 30 * 60 * 1000); // Add 30 minutes

    // Format date as YYYYMMDDTHHMMSS
    const formatDateForCalendar = (date: Date): string => {
      const year = date.getUTCFullYear();
      const month = String(date.getUTCMonth() + 1).padStart(2, '0');
      const day = String(date.getUTCDate()).padStart(2, '0');
      const hours = String(date.getUTCHours()).padStart(2, '0');
      const minutes = String(date.getUTCMinutes()).padStart(2, '0');
      const seconds = String(date.getUTCSeconds()).padStart(2, '0');
      return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };

    const startFormatted = formatDateForCalendar(startDate);
    const endFormatted = formatDateForCalendar(endDate);

    return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=Robert+Ventures+Investment+Webinar&dates=${startFormatted}/${endFormatted}&details=Join+us+live+at+robertventures.com/webinar`;
  }

  // ────────────────────────────────────────────────────────────────────────────
  // Meta Pixel helpers for deduplication
  // ────────────────────────────────────────────────────────────────────────────
  function generateEventId() {
    try {
      const buf = new Uint32Array(2);
      crypto.getRandomValues(buf);
      return `rv_reg_${Date.now().toString(36)}_${buf[0].toString(36)}${buf[1].toString(36)}`;
    } catch {
      return `rv_reg_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
    }
  }

  function getCookie(name) {
    try {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
    } catch {}
    return undefined;
  }

  function getFbp() {
    return getCookie('_fbp');
  }

  function getFbc() {
    const fbcCookie = getCookie('_fbc');
    if (fbcCookie) return fbcCookie;
    try {
      const url = new URL(window.location.href);
      const fbclid = url.searchParams.get('fbclid');
      if (fbclid) {
        // Build fbc from fbclid if cookie is not yet set
        const ts = Math.floor(Date.now() / 1000);
        return `fb.1.${ts}.${fbclid}`;
      }
    } catch {}
    return undefined;
  }
</script>
